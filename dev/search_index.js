var documenterSearchIndex = {"docs":
[{"location":"preallocationtools/#API","page":"API","title":"API","text":"","category":"section"},{"location":"preallocationtools/#PreallocationTools.DiffCache","page":"API","title":"PreallocationTools.DiffCache","text":"DiffCache(u::AbstractArray, N::Int = ForwardDiff.pickchunksize(length(u)); levels::Int = 1) DiffCache(u::AbstractArray; N::AbstractArray{<:Int})\n\nBuilds a DiffCache object that stores both a version of the cache for u and for the Dual version of u, allowing use of pre-cached vectors with forward-mode automatic differentiation. Supports nested AD via keyword levels or specifying an array of chunk_sizes.\n\n\n\n\n\n","category":"type"},{"location":"preallocationtools/#PreallocationTools.FixedSizeDiffCache-Union{Tuple{AbstractArray}, Tuple{N}, Tuple{AbstractArray, Type{Val{N}}}} where N","page":"API","title":"PreallocationTools.FixedSizeDiffCache","text":"FixedSizeDiffCache(u::AbstractArray, N = Val{default_cache_size(length(u))})\n\nBuilds a FixedSizeDiffCache object that stores both a version of the cache for u and for the Dual version of u, allowing use of pre-cached vectors with forward-mode automatic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"preallocationtools/#PreallocationTools.GeneralLazyBufferCache","page":"API","title":"PreallocationTools.GeneralLazyBufferCache","text":"b = GeneralLazyBufferCache(f=identity)\n\nA lazily allocated buffer object.  Given an array u, b[u] returns a cache object generated by f(u), but the generator is only run the first time (and all subsequent times it reuses the same cache)\n\nLimitation\n\nThe main limitation of this method is that its return is not type-inferred, and thus it can be slower than some other preallocation techniques. However, if used correct using things like function barriers, then this is a general technique that is sufficiently fast.\n\n\n\n\n\n","category":"type"},{"location":"preallocationtools/#PreallocationTools.LazyBufferCache","page":"API","title":"PreallocationTools.LazyBufferCache","text":"b = LazyBufferCache(f = identity; initializer! = identity)\n\nA lazily allocated buffer object.  Given an array u, b[u] returns an array of the same type and size f(size(u)) (defaulting to the same size), which is allocated as needed and then cached within b for subsequent usage.\n\nBy default the created buffers are not initialized, but a function initializer! can be supplied which is applied to the buffer when it is created, for instance buf -> fill!(buf, 0.0).\n\nOptionally, the size can be explicitly given at calltime using b[u,s], which will return a cache of size s.\n\n\n\n\n\n","category":"type"},{"location":"preallocationtools/#PreallocationTools.get_tmp-Union{Tuple{T}, Tuple{DiffCache, T}} where T<:ForwardDiff.Dual","page":"API","title":"PreallocationTools.get_tmp","text":"get_tmp(dc::DiffCache, u)\n\nReturns the Dual or normal cache array stored in dc based on the type of u.\n\n\n\n\n\n","category":"method"},{"location":"#PreallocationTools.jl","page":"Home","title":"PreallocationTools.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PreallocationTools.jl is a set of tools for helping build non-allocating pre-cached functions for high-performance computing in Julia. Its tools handle edge cases of automatic differentiation to make it easier for users to get high performance, even in the cases where code generation may change the function that is being called.","category":"page"},{"location":"#DiffCache","page":"Home","title":"DiffCache","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffCache is a method for generating doubly-preallocated vectors which are compatible with non-allocating forward-mode automatic differentiation by ForwardDiff.jl. Since ForwardDiff uses chunked duals in its forward pass, two vector sizes are required in order for the arrays to be properly defined. DiffCache creates a dispatching type to solve this, so that by passing a qualifier it can automatically switch between the required cache. This method is fully type-stable and non-dynamic, made for when the highest performance is needed.","category":"page"},{"location":"#Using-DiffCache","page":"Home","title":"Using DiffCache","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffCache(u::AbstractArray, N::Int = ForwardDiff.pickchunksize(length(u)); levels::Int = 1)\nDiffCache(u::AbstractArray, N::AbstractArray{<:Int})","category":"page"},{"location":"","page":"Home","title":"Home","text":"The DiffCache function builds a DiffCache object that stores both a version of the cache for u and for the Dual version of u, allowing use of pre-cached vectors with forward-mode automatic differentiation. Note that DiffCache, due to its design, is only compatible with arrays that contain concretely typed elements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To access the caches, one uses:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_tmp(tmp::DiffCache, u)","category":"page"},{"location":"","page":"Home","title":"Home","text":"When u has an element subtype of Dual numbers, then it returns the Dual version of the cache. Otherwise, it returns the standard cache (for use in the calls without automatic differentiation).","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to preallocate to the right size, the DiffCache needs to be specified to have the correct N matching the chunk size of the dual numbers or larger. If the chunk size N specified is too large, get_tmp will automatically resize when dispatching; this remains type-stable and non-allocating, but comes at the expense of additional memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a differential equation, optimization, etc., the default chunk size is computed from the state vector u, and thus if one creates the DiffCache via DiffCache(u) it will match the default chunking of the solver libraries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DiffCache is also compatible with nested automatic differentiation calls through the levels keyword (N for each level computed using based on the size of the state vector) or by specifying N as an array of integers of chunk sizes, which enables full control of chunk sizes on all differentiation levels.","category":"page"},{"location":"#DiffCache-Example-1:-Direct-Usage","page":"Home","title":"DiffCache Example 1: Direct Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using ForwardDiff, PreallocationTools\nrandmat = rand(5, 3)\nsto = similar(randmat)\nstod = DiffCache(sto)\n\nfunction claytonsample!(sto, τ, α; randmat = randmat)\n    sto = get_tmp(sto, τ)\n    sto .= randmat\n    τ == 0 && return sto\n\n    n = size(sto, 1)\n    for i in 1:n\n        v = sto[i, 2]\n        u = sto[i, 1]\n        sto[i, 1] = (1 - u^(-τ) + u^(-τ) * v^(-(τ / (1 + τ))))^(-1 / τ) * α\n        sto[i, 2] = (1 - u^(-τ) + u^(-τ) * v^(-(τ / (1 + τ))))^(-1 / τ)\n    end\n    return sto\nend\n\nForwardDiff.derivative(τ -> claytonsample!(stod, τ, 0.0), 0.3)\nForwardDiff.jacobian(x -> claytonsample!(stod, x[1], x[2]), [0.3; 0.0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the above, the chunk size of the dual numbers has been selected based on the size of randmat, resulting in a chunk size of 8 in this case. However, since the derivative is calculated with respect to τ and the Jacobian is calculated with respect to τ and α, specifying the DiffCache with stod = DiffCache(sto, 1) or stod = DiffCache(sto, 2), respectively, would have been the most memory efficient way of performing these calculations (only really relevant for much larger problems).","category":"page"},{"location":"#DiffCache-Example-2:-ODEs","page":"Home","title":"DiffCache Example 2: ODEs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra, OrdinaryDiffEq\nfunction foo(du, u, (A, tmp), t)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0), (ones(5, 5), zeros(5, 5)))\nsolve(prob, TRBDF2())","category":"page"},{"location":"","page":"Home","title":"Home","text":"fails because tmp is only real numbers, but during automatic differentiation we need tmp to be a cache of dual numbers. Since u is the value that will have the dual numbers, we dispatch based on that:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra, OrdinaryDiffEq, PreallocationTools\nfunction foo(du, u, (A, tmp), t)\n    tmp = get_tmp(tmp, u)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nchunk_size = 5\nprob = ODEProblem(foo,\n    ones(5, 5),\n    (0.0, 1.0),\n    (ones(5, 5), DiffCache(zeros(5, 5), chunk_size)))\nsolve(prob, TRBDF2(chunk_size = chunk_size))","category":"page"},{"location":"","page":"Home","title":"Home","text":"or just using the default chunking:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra, OrdinaryDiffEq, PreallocationTools\nfunction foo(du, u, (A, tmp), t)\n    tmp = get_tmp(tmp, u)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nchunk_size = 5\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0), (ones(5, 5), DiffCache(zeros(5, 5))))\nsolve(prob, TRBDF2())","category":"page"},{"location":"#DiffCache-Example-3:-Nested-AD-calls-in-an-optimization-problem-involving-a-Hessian-matrix","page":"Home","title":"DiffCache Example 3: Nested AD calls in an optimization problem involving a Hessian matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra, OrdinaryDiffEq, PreallocationTools, Optim, Optimization\nfunction foo(du, u, p, t)\n    tmp = p[2]\n    A = reshape(p[1], size(tmp.du))\n    tmp = get_tmp(tmp, u)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\n\ncoeffs = -collect(0.1:0.1:0.4)\ncache = DiffCache(zeros(2, 2), levels = 3)\nprob = ODEProblem(foo, ones(2, 2), (0.0, 1.0), (coeffs, cache))\nrealsol = solve(prob, TRBDF2(), saveat = 0.0:0.1:10.0, reltol = 1e-8)\n\nfunction objfun(x, prob, realsol, cache)\n    prob = remake(prob, u0 = eltype(x).(prob.u0), p = (x, cache))\n    sol = solve(prob, TRBDF2(), saveat = 0.0:0.1:10.0, reltol = 1e-8)\n\n    ofv = 0.0\n    if any((s.retcode != :Success for s in sol))\n        ofv = 1e12\n    else\n        ofv = sum((sol .- realsol) .^ 2)\n    end\n    return ofv\nend\nfn(x, p) = objfun(x, p[1], p[2], p[3])\noptfun = OptimizationFunction(fn, Optimization.AutoForwardDiff())\noptprob = OptimizationProblem(optfun, zeros(length(coeffs)), (prob, realsol, cache))\nsolve(optprob, Newton())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solves an optimization problem for the coefficients, coeffs, appearing in a differential equation. The optimization is done with Optim.jl's Newton() algorithm. Since this involves automatic differentiation in the ODE solver and the calculation of Hessians, three automatic differentiations are nested within each other. Therefore, the DiffCache is specified with levels = 3.","category":"page"},{"location":"#FixedSizeDiffCache","page":"Home","title":"FixedSizeDiffCache","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FixedSizeDiffCache is a lot like DiffCache, but it stores dual numbers in its caches instead of a flat array. Because of this, it can avoid a view, making it a little more performant for generating caches of non-Array types. However, it is a lot less flexible than DiffCache, and is thus only recommended for cases where the chunk size is known in advance (for example, ODE solvers) and where u is not an Array.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The interface is almost exactly the same, except with the constructor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"FixedSizeDiffCache(u::AbstractArray, chunk_size = Val{ForwardDiff.pickchunksize(length(u))})\nFixedSizeDiffCache(u::AbstractArray, chunk_size::Integer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the FixedSizeDiffCache can support duals that are of a small chunk size than the preallocated ones, but not a larger size. Nested duals are not supported with this construct.","category":"page"},{"location":"#LazyBufferCache","page":"Home","title":"LazyBufferCache","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LazyBufferCache(f::F = identity)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A LazyBufferCache is a Dict-like type for the caches, which automatically defines new cache arrays on demand when they are required. The function f maps size_of_cache = f(size(u)), which by default creates cache arrays of the same size.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default the created buffers are not initialized, but a function initializer! can be supplied which is applied to the buffer when it is created, for instance buf -> fill!(buf, 0.0).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that LazyBufferCache is type-stable and contains no dynamic dispatch. This gives it a ~15ns overhead. The upside of LazyBufferCache is that the user does not have to worry about potential issues with chunk sizes and such: LazyBufferCache is much easier!","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra, OrdinaryDiffEq, PreallocationTools\nfunction foo(du, u, (A, lbc), t)\n    tmp = lbc[u]\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0), (ones(5, 5), LazyBufferCache()))\nsolve(prob, TRBDF2())","category":"page"},{"location":"#Note-About-ReverseDiff-Support-for-LazyBuffer","page":"Home","title":"Note About ReverseDiff Support for LazyBuffer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReverseDiff support is done in SciMLSensitivity.jl to reduce the AD requirements on this package. Load that package if ReverseDiff overloads are required.","category":"page"},{"location":"#GeneralLazyBufferCache","page":"Home","title":"GeneralLazyBufferCache","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GeneralLazyBufferCache(f = identity)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A GeneralLazyBufferCache is a Dict-like type for the caches, which automatically defines new caches on demand when they are required. The function f generates the cache matching for the type of u, and subsequent indexing reuses that cache if that type of u has already been seen.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that GeneralLazyBufferCache's return is not type-inferred. This means it's the slowest of the preallocation methods, but it's the most general.","category":"page"},{"location":"#Example-2","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In all the previous cases, our cache was an array. However, in this case, we want to preallocate a DifferentialEquations ODEIntegrator object. This object is the one created via DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t), and we want to optimize p in a way that changes its type to ForwardDiff. Thus, what we can do is make a GeneralLazyBufferCache which holds these integrator objects, defined by p, and indexing it with p in order to retrieve the cache. The first time it's called it will build the integrator, and in subsequent calls it will reuse the cache.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Defining the cache as a function of p to build an integrator thus looks like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lbc = GeneralLazyBufferCache(function (p)\n    DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t)\nend)","category":"page"},{"location":"","page":"Home","title":"Home","text":"then lbc[p] will be smart and reuse the caches. A full example looks like the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Random, DifferentialEquations, LinearAlgebra, Optimization, OptimizationNLopt,\n      OptimizationOptimJL, PreallocationTools\n\nlbc = GeneralLazyBufferCache(function (p)\n    DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t)\nend)\n\nRandom.seed!(2992999)\nλ, y₀, σ = -0.5, 15.0, 0.1\nT, n = 5.0, 200\nΔt = T / n\nt = [j * Δt for j in 0:n]\ny = y₀ * exp.(λ * t)\nyᵒ = y .+ [0.0, σ * randn(n)...]\node_fnc(u, p, t) = p * u\nfunction loglik(θ, data, integrator)\n    yᵒ, n, ε = data\n    λ, σ, u0 = θ\n    integrator.p = λ\n    reinit!(integrator, u0)\n    solve!(integrator)\n    ε = yᵒ .- integrator.sol.u\n    ℓ = -0.5n * log(2π * σ^2) - 0.5 / σ^2 * sum(ε .^ 2)\nend\nθ₀ = [-1.0, 0.5, 19.73]\nnegloglik = (θ, p) -> -loglik(θ, p, lbc[θ[1]])\nfnc = OptimizationFunction(negloglik, Optimization.AutoForwardDiff())\nε = zeros(n)\nprob = OptimizationProblem(fnc,\n    θ₀,\n    (yᵒ, n, ε),\n    lb = [-10.0, 1e-6, 0.5],\n    ub = [10.0, 10.0, 25.0])\nsolve(prob, LBFGS())","category":"page"},{"location":"#Similar-Projects","page":"Home","title":"Similar Projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoPreallocation.jl tries to do this automatically at the compiler level. Alloc.jl tries to do this with a bump allocator.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"preallocationtools/#API","page":"API","title":"API","text":"","category":"section"},{"location":"preallocationtools/#PreallocationTools.DiffCache","page":"API","title":"PreallocationTools.DiffCache","text":"DiffCache(u::AbstractArray, N::Int = forwarddiff_compat_chunk_size(length(u)); levels::Int = 1) DiffCache(u::AbstractArray; N::AbstractArray{<:Int})\n\nBuilds a DiffCache object that stores both a version of the cache for u and for the Dual version of u, allowing use of pre-cached vectors with forward-mode automatic differentiation via ForwardDiff.jl (when available). Supports nested AD via keyword levels or specifying an array of chunk sizes.\n\nThe DiffCache also supports sparsity detection via SparseConnectivityTracer.jl.\n\n\n\n\n\n","category":"type"},{"location":"preallocationtools/#PreallocationTools.FixedSizeDiffCache-Union{Tuple{AbstractArray}, Tuple{N}, Tuple{AbstractArray, Type{Val{N}}}} where N","page":"API","title":"PreallocationTools.FixedSizeDiffCache","text":"FixedSizeDiffCache(u::AbstractArray, N = Val{default_cache_size(length(u))})\n\nBuilds a FixedSizeDiffCache object that stores both a version of the cache for u and for the Dual version of u, allowing use of pre-cached vectors with forward-mode automatic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"preallocationtools/#PreallocationTools.GeneralLazyBufferCache","page":"API","title":"PreallocationTools.GeneralLazyBufferCache","text":"b = GeneralLazyBufferCache(f=identity)\n\nA lazily allocated buffer object.  Given an array u, b[u] returns a cache object generated by f(u), but the generator is only run the first time (and all subsequent times it reuses the same cache)\n\nLimitation\n\nThe main limitation of this method is that its return is not type-inferred, and thus it can be slower than some other preallocation techniques. However, if used correct using things like function barriers, then this is a general technique that is sufficiently fast.\n\n\n\n\n\n","category":"type"},{"location":"preallocationtools/#PreallocationTools.LazyBufferCache","page":"API","title":"PreallocationTools.LazyBufferCache","text":"b = LazyBufferCache(f = identity; initializer! = identity)\n\nA lazily allocated buffer object.  Given an array u, b[u] returns an array of the same type and size f(size(u)) (defaulting to the same size), which is allocated as needed and then cached within b for subsequent usage.\n\nBy default the created buffers are not initialized, but a function initializer! can be supplied which is applied to the buffer when it is created, for instance buf -> fill!(buf, 0.0).\n\nOptionally, the size can be explicitly given at calltime using b[u,s], which will return a cache of size s.\n\n\n\n\n\n","category":"type"},{"location":"preallocationtools/#Base.fill!-Tuple{DiffCache, Any}","page":"API","title":"Base.fill!","text":"fill!(dc::DiffCache, val)\n\nFill all allocated buffers in the DiffCache with the given value.\n\n\n\n\n\n","category":"method"},{"location":"preallocationtools/#Base.fill!-Tuple{FixedSizeDiffCache, Any}","page":"API","title":"Base.fill!","text":"fill!(dc::FixedSizeDiffCache, val)\n\nFill all allocated buffers in the FixedSizeDiffCache with the given value.\n\n\n\n\n\n","category":"method"},{"location":"preallocationtools/#Base.fill!-Tuple{GeneralLazyBufferCache, Any}","page":"API","title":"Base.fill!","text":"fill!(glbc::GeneralLazyBufferCache, val)\n\nFill all allocated buffers in the GeneralLazyBufferCache with the given value.\n\n\n\n\n\n","category":"method"},{"location":"preallocationtools/#Base.fill!-Tuple{LazyBufferCache, Any}","page":"API","title":"Base.fill!","text":"fill!(lbc::LazyBufferCache, val)\n\nFill all allocated buffers in the LazyBufferCache with the given value.\n\n\n\n\n\n","category":"method"},{"location":"preallocationtools/#PreallocationTools._restructure-Tuple{Array, Any}","page":"API","title":"PreallocationTools._restructure","text":"_restructure(normal_cache::AbstractArray, duals)\n\nInternal function that reshapes a flat array of dual numbers to match the shape of the normal cache array. For standard Array types, uses reshape. For other AbstractArray types, delegates to ArrayInterface.restructure to handle custom array types properly.\n\n\n\n\n\n","category":"method"},{"location":"preallocationtools/#PreallocationTools.get_tmp-Tuple{FixedSizeDiffCache, Union{Number, AbstractArray}}","page":"API","title":"PreallocationTools.get_tmp","text":"get_tmp(dc::FixedSizeDiffCache, u::Union{Number, AbstractArray})\n\nReturns the appropriate cache array from the FixedSizeDiffCache based on the type of u.\n\nIf u is a regular array or number, returns the standard cache dc.du. If u contains dual numbers (e.g., from ForwardDiff.jl), returns the dual cache array. The function automatically handles type promotion and resizing of internal caches as needed.\n\nThis function enables seamless switching between regular and automatic differentiation computations without manual cache management.\n\n\n\n\n\n","category":"method"},{"location":"#PreallocationTools.jl","page":"Home","title":"PreallocationTools.jl","text":"PreallocationTools.jl is a set of tools for helping build non-allocating pre-cached functions for high-performance computing in Julia. Its tools handle edge cases of automatic differentiation to make it easier for users to get high performance, even in the cases where code generation may change the function that is being called.","category":"section"},{"location":"#DiffCache","page":"Home","title":"DiffCache","text":"DiffCache is a method for generating doubly-preallocated vectors which are compatible with non-allocating forward-mode automatic differentiation by ForwardDiff.jl. Since ForwardDiff uses chunked duals in its forward pass, two vector sizes are required in order for the arrays to be properly defined. DiffCache creates a dispatching type to solve this, so that by passing a qualifier it can automatically switch between the required cache. This method is fully type-stable and non-dynamic, made for when the highest performance is needed.","category":"section"},{"location":"#Using-DiffCache","page":"Home","title":"Using DiffCache","text":"DiffCache(u::AbstractArray, N::Int = ForwardDiff.pickchunksize(length(u)); levels::Int = 1)\nDiffCache(u::AbstractArray, N::AbstractArray{<:Int})\n\nThe DiffCache function builds a DiffCache object that stores both a version of the cache for u and for the Dual version of u, allowing use of pre-cached vectors with forward-mode automatic differentiation. Note that DiffCache, due to its design, is only compatible with arrays that contain concretely typed elements.\n\nTo access the caches, one uses:\n\nget_tmp(tmp::DiffCache, u)\n\nWhen u has an element subtype of Dual numbers, then it returns the Dual version of the cache. Otherwise, it returns the standard cache (for use in the calls without automatic differentiation).\n\nIn order to preallocate to the right size, the DiffCache needs to be specified to have the correct N matching the chunk size of the dual numbers or larger. If the chunk size N specified is too large, get_tmp will automatically resize when dispatching; this remains type-stable and non-allocating, but comes at the expense of additional memory.\n\nIn a differential equation, optimization, etc., the default chunk size is computed from the state vector u, and thus if one creates the DiffCache via DiffCache(u) it will match the default chunking of the solver libraries.\n\nDiffCache is also compatible with nested automatic differentiation calls through the levels keyword (N for each level computed using based on the size of the state vector) or by specifying N as an array of integers of chunk sizes, which enables full control of chunk sizes on all differentiation levels.","category":"section"},{"location":"#DiffCache-Example-1:-Direct-Usage","page":"Home","title":"DiffCache Example 1: Direct Usage","text":"using ForwardDiff, PreallocationTools\nrandmat = rand(5, 3)\nsto = similar(randmat)\nstod = DiffCache(sto)\n\nfunction claytonsample!(sto, τ, α; randmat = randmat)\n    sto = get_tmp(sto, τ)\n    sto .= randmat\n    τ == 0 && return sto\n\n    n = size(sto, 1)\n    for i in 1:n\n        v = sto[i, 2]\n        u = sto[i, 1]\n        sto[i, 1] = (1 - u^(-τ) + u^(-τ) * v^(-(τ / (1 + τ))))^(-1 / τ) * α\n        sto[i, 2] = (1 - u^(-τ) + u^(-τ) * v^(-(τ / (1 + τ))))^(-1 / τ)\n    end\n    return sto\nend\n\nForwardDiff.derivative(τ -> claytonsample!(stod, τ, 0.0), 0.3)\nForwardDiff.jacobian(x -> claytonsample!(stod, x[1], x[2]), [0.3; 0.0])\n\nIn the above, the chunk size of the dual numbers has been selected based on the size of randmat, resulting in a chunk size of 8 in this case. However, since the derivative is calculated with respect to τ and the Jacobian is calculated with respect to τ and α, specifying the DiffCache with stod = DiffCache(sto, 1) or stod = DiffCache(sto, 2), respectively, would have been the most memory efficient way of performing these calculations (only really relevant for much larger problems).","category":"section"},{"location":"#DiffCache-Example-2:-ODEs","page":"Home","title":"DiffCache Example 2: ODEs","text":"using LinearAlgebra, OrdinaryDiffEq\nfunction foo(du, u, (A, tmp), t)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0), (ones(5, 5), zeros(5, 5)))\nsolve(prob, TRBDF2())\n\nfails because tmp is only real numbers, but during automatic differentiation we need tmp to be a cache of dual numbers. Since u is the value that will have the dual numbers, we dispatch based on that:\n\nusing LinearAlgebra, OrdinaryDiffEq, PreallocationTools\nfunction foo(du, u, (A, tmp), t)\n    tmp = get_tmp(tmp, u)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nchunk_size = 5\nprob = ODEProblem(foo,\n    ones(5, 5),\n    (0.0, 1.0),\n    (ones(5, 5), DiffCache(zeros(5, 5), chunk_size)))\nsolve(prob, TRBDF2(chunk_size = chunk_size))\n\nor just using the default chunking:\n\nusing LinearAlgebra, OrdinaryDiffEq, PreallocationTools\nfunction foo(du, u, (A, tmp), t)\n    tmp = get_tmp(tmp, u)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nchunk_size = 5\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0), (ones(5, 5), DiffCache(zeros(5, 5))))\nsolve(prob, TRBDF2())","category":"section"},{"location":"#DiffCache-Example-3:-Nested-AD-calls-in-an-optimization-problem-involving-a-Hessian-matrix","page":"Home","title":"DiffCache Example 3: Nested AD calls in an optimization problem involving a Hessian matrix","text":"using LinearAlgebra, OrdinaryDiffEq, PreallocationTools, Optim, Optimization\nfunction foo(du, u, p, t)\n    tmp = p[2]\n    A = reshape(p[1], size(tmp.du))\n    tmp = get_tmp(tmp, u)\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\n\ncoeffs = -collect(0.1:0.1:0.4)\ncache = DiffCache(zeros(2, 2), levels = 3)\nprob = ODEProblem(foo, ones(2, 2), (0.0, 1.0), (coeffs, cache))\nrealsol = solve(prob, TRBDF2(), saveat = 0.0:0.1:10.0, reltol = 1e-8)\n\nfunction objfun(x, prob, realsol, cache)\n    prob = remake(prob, u0 = eltype(x).(prob.u0), p = (x, cache))\n    sol = solve(prob, TRBDF2(), saveat = 0.0:0.1:10.0, reltol = 1e-8)\n\n    ofv = 0.0\n    if any((s.retcode != :Success for s in sol))\n        ofv = 1e12\n    else\n        ofv = sum((sol .- realsol) .^ 2)\n    end\n    return ofv\nend\nfn(x, p) = objfun(x, p[1], p[2], p[3])\noptfun = OptimizationFunction(fn, Optimization.AutoForwardDiff())\noptprob = OptimizationProblem(optfun, zeros(length(coeffs)), (prob, realsol, cache))\nsolve(optprob, Newton())\n\nSolves an optimization problem for the coefficients, coeffs, appearing in a differential equation. The optimization is done with Optim.jl's Newton() algorithm. Since this involves automatic differentiation in the ODE solver and the calculation of Hessians, three automatic differentiations are nested within each other. Therefore, the DiffCache is specified with levels = 3.","category":"section"},{"location":"#FixedSizeDiffCache","page":"Home","title":"FixedSizeDiffCache","text":"FixedSizeDiffCache is a lot like DiffCache, but it stores dual numbers in its caches instead of a flat array. Because of this, it can avoid a view, making it a little more performant for generating caches of non-Array types. However, it is a lot less flexible than DiffCache, and is thus only recommended for cases where the chunk size is known in advance (for example, ODE solvers) and where u is not an Array.\n\nThe interface is almost exactly the same, except with the constructor:\n\nFixedSizeDiffCache(u::AbstractArray, chunk_size = Val{ForwardDiff.pickchunksize(length(u))})\nFixedSizeDiffCache(u::AbstractArray, chunk_size::Integer)\n\nNote that the FixedSizeDiffCache can support duals that are of a small chunk size than the preallocated ones, but not a larger size. Nested duals are not supported with this construct.","category":"section"},{"location":"#LazyBufferCache","page":"Home","title":"LazyBufferCache","text":"LazyBufferCache(f::F = identity)\n\nA LazyBufferCache is a Dict-like type for the caches, which automatically defines new cache arrays on demand when they are required. The function f maps size_of_cache = f(size(u)), which by default creates cache arrays of the same size.\n\nBy default the created buffers are not initialized, but a function initializer! can be supplied which is applied to the buffer when it is created, for instance buf -> fill!(buf, 0.0).\n\nNote that LazyBufferCache is type-stable and contains no dynamic dispatch. This gives it a ~15ns overhead. The upside of LazyBufferCache is that the user does not have to worry about potential issues with chunk sizes and such: LazyBufferCache is much easier!","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"using LinearAlgebra, OrdinaryDiffEq, PreallocationTools\nfunction foo(du, u, (A, lbc), t)\n    tmp = lbc[u]\n    mul!(tmp, A, u)\n    @. du = u + tmp\n    nothing\nend\nprob = ODEProblem(foo, ones(5, 5), (0.0, 1.0), (ones(5, 5), LazyBufferCache()))\nsolve(prob, TRBDF2())","category":"section"},{"location":"#Note-About-ReverseDiff-Support-for-LazyBuffer","page":"Home","title":"Note About ReverseDiff Support for LazyBuffer","text":"ReverseDiff support is done in SciMLSensitivity.jl to reduce the AD requirements on this package. Load that package if ReverseDiff overloads are required.","category":"section"},{"location":"#GeneralLazyBufferCache","page":"Home","title":"GeneralLazyBufferCache","text":"GeneralLazyBufferCache(f = identity)\n\nA GeneralLazyBufferCache is a Dict-like type for the caches, which automatically defines new caches on demand when they are required. The function f generates the cache matching for the type of u, and subsequent indexing reuses that cache if that type of u has already been seen.\n\nNote that GeneralLazyBufferCache's return is not type-inferred. This means it's the slowest of the preallocation methods, but it's the most general.","category":"section"},{"location":"#Example-2","page":"Home","title":"Example","text":"In all the previous cases, our cache was an array. However, in this case, we want to preallocate a DifferentialEquations ODEIntegrator object. This object is the one created via DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t), and we want to optimize p in a way that changes its type to ForwardDiff. Thus, what we can do is make a GeneralLazyBufferCache which holds these integrator objects, defined by p, and indexing it with p in order to retrieve the cache. The first time it's called it will build the integrator, and in subsequent calls it will reuse the cache.\n\nDefining the cache as a function of p to build an integrator thus looks like:\n\nlbc = GeneralLazyBufferCache(function (p)\n    DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t)\nend)\n\nthen lbc[p] will be smart and reuse the caches. A full example looks like the following:\n\nusing Random, DifferentialEquations, LinearAlgebra, Optimization, OptimizationNLopt,\n      OptimizationOptimJL, PreallocationTools\n\nlbc = GeneralLazyBufferCache(function (p)\n    DifferentialEquations.init(ODEProblem(ode_fnc, y₀, (0.0, T), p), Tsit5(); saveat = t)\nend)\n\nRandom.seed!(2992999)\nλ, y₀, σ = -0.5, 15.0, 0.1\nT, n = 5.0, 200\nΔt = T / n\nt = [j * Δt for j in 0:n]\ny = y₀ * exp.(λ * t)\nyᵒ = y .+ [0.0, σ * randn(n)...]\node_fnc(u, p, t) = p * u\nfunction loglik(θ, data, integrator)\n    yᵒ, n, ε = data\n    λ, σ, u0 = θ\n    integrator.p = λ\n    reinit!(integrator, u0)\n    solve!(integrator)\n    ε = yᵒ .- integrator.sol.u\n    ℓ = -0.5n * log(2π * σ^2) - 0.5 / σ^2 * sum(ε .^ 2)\nend\nθ₀ = [-1.0, 0.5, 19.73]\nnegloglik = (θ, p) -> -loglik(θ, p, lbc[θ[1]])\nfnc = OptimizationFunction(negloglik, Optimization.AutoForwardDiff())\nε = zeros(n)\nprob = OptimizationProblem(fnc,\n    θ₀,\n    (yᵒ, n, ε),\n    lb = [-10.0, 1e-6, 0.5],\n    ub = [10.0, 10.0, 25.0])\nsolve(prob, LBFGS())","category":"section"},{"location":"#Similar-Projects","page":"Home","title":"Similar Projects","text":"AutoPreallocation.jl tries to do this automatically at the compiler level. Alloc.jl tries to do this with a bump allocator.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"section"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"section"},{"location":"internals/#Internal-Functions","page":"Internals","title":"Internal Functions","text":"This page documents internal functions that are not part of the public API but may be encountered during debugging or when extending PreallocationTools.jl functionality.\n\nwarning: Warning\nThese are internal implementation details and may change without notice in any release. They should not be relied upon for user code.","category":"section"},{"location":"internals/#Internal-Helper-Functions","page":"Internals","title":"Internal Helper Functions","text":"","category":"section"},{"location":"internals/#PreallocationTools.enlargediffcache!","page":"Internals","title":"PreallocationTools.enlargediffcache!","text":"enlargediffcache!(dc::DiffCache, nelem::Integer)\n\nEnlarges the dual cache array in a DiffCache when it's found to be too small.\n\nThis function is called internally when automatic differentiation requires a larger dual cache than initially allocated. It resizes dc.dual_du to accommodate nelem elements and issues a one-time warning suggesting an appropriate chunk size for optimal performance.\n\nArguments\n\ndc: The DiffCache object to enlarge\nnelem: The new required number of elements\n\nNotes\n\nThe warning is shown only once per DiffCache instance to avoid spam. For optimal performance in production code, pre-allocate with the suggested chunk size to avoid runtime allocations.\n\n\n\n\n\n","category":"function"}]
}
